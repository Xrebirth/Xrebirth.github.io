<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小靳同学</title>
  
  <subtitle>是小靳同学啊</subtitle>
  <link href="http://xrebirth.github.io/atom.xml" rel="self"/>
  
  <link href="http://xrebirth.github.io/"/>
  <updated>2021-06-05T19:33:23.452Z</updated>
  <id>http://xrebirth.github.io/</id>
  
  <author>
    <name>小靳同学</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://xrebirth.github.io/posts/4a17b156.html"/>
    <id>http://xrebirth.github.io/posts/4a17b156.html</id>
    <published>2021-06-08T17:04:55.651Z</published>
    <updated>2021-06-05T19:33:23.452Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据库构成(01)</title>
    <link href="http://xrebirth.github.io/posts/5f8d3e42.html"/>
    <id>http://xrebirth.github.io/posts/5f8d3e42.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:02:02.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1节：数据库构成"><a href="#第1节：数据库构成" class="headerlink" title="第1节：数据库构成"></a>第1节：数据库构成</h1><ol><li><p>系统数据库<br> 系统数据库是指MySQL安装配置完成之后，系统自动创建的一些数据库。</p><blockquote><p>以下四种都是系统数据库：</p><ol><li>information_schema：主要存储系统中一些数据库对象信息，包括用户信息、字符集信息和分区信息等…</li><li>mysql：主要存储账户信息、权限信息、存储过程和时区信息等…</li><li>performance_schema：主要用于收集数据库服务器性能参数。</li><li>sys：该库通过视图的形式把<strong>information_schema</strong>和<strong>performance_schema</strong>结合起来，查询出更容易理解的数据，帮助DBA快速获取数据库系统的各种数据库的对象信息，使DBA和开发人员能够快速定位性能瓶颈。</li></ol></blockquote></li><li><p>用户数据库<br> 用户数据库是根据用户根据实际需求手动创建的数据库。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第1节：数据库构成&quot;&gt;&lt;a href=&quot;#第1节：数据库构成&quot; class=&quot;headerlink&quot; title=&quot;第1节：数据库构成&quot;&gt;&lt;/a&gt;第1节：数据库构成&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;系统数据库&lt;br&gt; 系统数据库是指MySQL安装配置完成之后，系统</summary>
      
    
    
    
    <category term="MySQL" scheme="http://xrebirth.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://xrebirth.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常用命令(02)</title>
    <link href="http://xrebirth.github.io/posts/5f8d3e42.html"/>
    <id>http://xrebirth.github.io/posts/5f8d3e42.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:01:52.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第2节：数据库常用命令"><a href="#第2节：数据库常用命令" class="headerlink" title="第2节：数据库常用命令"></a>第2节：数据库常用命令</h1><h4 id="常用数据库命令集："><a href="#常用数据库命令集：" class="headerlink" title="常用数据库命令集："></a>常用数据库命令集：</h4><h2 id="创建数据库命令："><a href="#创建数据库命令：" class="headerlink" title="创建数据库命令："></a>创建数据库命令：</h2><ol><li><strong>show databases;</strong><br><br> 查看所有数据库</li><li><strong>create database &lt;数据库名称&gt;;</strong><br><br> 创建数据库</li><li><strong>use &lt;数据库名称&gt;;</strong><br><br> 选择数据库</li><li><strong>drop database &lt;数据库名称&gt;;</strong><br><br> 删除数据库</li><li><strong>create table  &lt;表名&gt;</strong> ( <br><br> 属性名 数据类型 [完整性约束条件],<br><br> 属性名 数据类型 [完整性约束条件],<br><br> ……<br><br> 属性名 数据类型 [完整性约束条件]<br> );<br> 创建数据表格式</li><li>完整性约束条件表：</li></ol><table><thead><tr><th align="center">命令</th><th align="center">约束条件</th></tr></thead><tbody><tr><td align="center">primary key</td><td align="center">主键</td></tr><tr><td align="center">foreign key</td><td align="center">外键</td></tr><tr><td align="center">not null</td><td align="center">非空约束</td></tr><tr><td align="center">unique</td><td align="center">唯一性约束</td></tr><tr><td align="center">auto_increment</td><td align="center">自增</td></tr><tr><td align="center">default</td><td align="center">默认值</td></tr><tr><td align="center">unsigned</td><td align="center">无符号约束</td></tr></tbody></table><p>功能性解释：</p><table><thead><tr><th align="center">约束条件</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">primary key</td><td align="center">主键，也称主码，用于标识表中的唯一的一条记录。一张表中只能有一个主键，并且主键值不能为空。</td></tr><tr><td align="center">foreign key</td><td align="center">在关系数据库中数据表之间是由关系来联系彼此的，一张数据表中的某个字段可能是另外一张数据表中的主键 ，为这个字段设置外键约束，就可以将这两个表关联在一起。设置外键约束的主要作用是保证数据的完整性。</td></tr><tr><td align="center">not null</td><td align="center">设置非空约束的作用是在规定的字段值内不能为空，用户在向数据表中插入数据时，如果设置非空约束的字段没有指定值，系统就会报错。</td></tr><tr><td align="center">unique</td><td align="center">当数据表中某个字段不允许重复时，可以使用唯一性约束，当用户在设置了唯一性约束的字段中插入的数据与数据表中已存在的数据相同时，系统会报错。</td></tr><tr><td align="center">auto_increment</td><td align="center">在向数据表中插入数据时，如果用户希望每天记录的”编号”自动生成，并且按照顺序排列，可以为该字段添加自增约束。</td></tr><tr><td align="center">default</td><td align="center">当向数据表中插入一条数据时，如果没有为某个字段赋值，那么系统就会将其值设置为null，如果为字段设置默认约束，则系统将默认值(null)插入到此字段中。</td></tr><tr><td align="center">unsigned</td><td align="center">规定此列所存储的数据不为负数。</td></tr></tbody></table><ol><li><strong>describe &lt;表名&gt;;</strong><br> 查看表结构</li><li>show create table &lt;表名&gt; \g;<br><br> 查看建表语句</li><li>alter table &lt;旧表名&gt; rename &lt;新表名&gt;;<br><br> 修改表名</li><li>alter table &lt;表名&gt; modify &lt;字段名&gt; &lt;修改数据类型&gt;;<br><br> 修改字段类型</li><li>alter table &lt;表名&gt; change &lt;旧字段名&gt; &lt;新字段名&gt; &lt;此字段的数据类型&gt;;<br><br> 修改字段名</li><li>alter table &lt;表名&gt; add &lt;字段名&gt; &lt;数据类型&gt; &lt;完整性约束条件&gt;;<br><br> 在最后一条添加字段</li><li>alter table &lt;表名&gt; add &lt;字段名&gt; &lt;数据类型&gt; &lt;完整性约束条件&gt; first;<br><br> 在第一行添加字段</li><li>alter table &lt;表名&gt; add &lt;字段名&gt; &lt;数据类型&gt; &lt;完整性约束条件&gt; after &lt;在这个字段之后添加，这里添加字段名&gt;;<br><br> 在指定字段后面添加字段</li><li>alter table &lt;表名&gt; orop &lt;字段名&gt;;<br><br> 删除字段</li><li>alter table &lt;表名&gt; modify &lt;想移动字段名称&gt; &lt;字段数据类型&gt; first;<br><br>移动字段到第一行</li><li>alter table &lt;表名&gt; modify &lt;想移动字段名称&gt; &lt;字段数据类型&gt; after &lt;在这个字段之后添加，这里添加字段名&gt;;<br><br>移动到指定字段之后</li><li>drop table &lt;表名1&gt;,&lt;表名2&gt;,&lt;表名3&gt; ………………..;<br><br>删除没有被关联的表，这里可以一次选多个，也可以选一个</li><li>alter table &lt;表名&gt; drop foreign key &lt;外键名称&gt;;<br><br>删除外键<br><br>如果数据表之间存在外键关联，那么直接删除主表，系统会提示错误信息，这种情况下，需要先删除与它关联的其他的表，在删除主表</li></ol><hr><h2 id="插入数据命令："><a href="#插入数据命令：" class="headerlink" title="插入数据命令："></a>插入数据命令：</h2><ol><li><p>insert into &lt;表名&gt; values (“数据值1”,”数据值2”,”数据值3”,”数据值4”,   ……);<br><br> 不指定具体字段名插入数据</p></li><li><p>insert into &lt;表名&gt; ( 字段名1,字段名2,字段名3,字段名4, …….)<br> values (“数据值1”,”数据值2”,”数据值3”,”数据值4”,   ……),<br>  (“数据值1”,”数据值2”,”数据值3”,”数据值4”,   ……);<br><br> 列出所有字段插入数据，注：上面的字段与下面插入的数据要一一对应</p></li><li><p>insert into &lt;表名&gt; ( 字段名1,字段名2,字段名3,字段名4, …….)<br> values (“数据值1”,”数据值2”,”数据值3”,”数据值4”,   ……),<br>  (“数据值1”,”数据值2”,”数据值3”,”数据值4”,   ……);<br><br> 指定表中字段插入数据&lt;上面字段名可以用户自己指定插入什么数据&gt;</p></li><li><p>insert into &lt;表名1&gt; (字段名1,字段名2,字段名3,字段名4, …….)<br> select ( 字段名1,字段名2,字段名3,字段名4, …….) from &lt;表名2&gt;;<br><br> 将表名2中的数据插入到表名1中的指定字段中去<br> 将其他表中的数据插入到表中</p></li><li><p>update &lt;表名&gt;<br> set &lt;字段名1&gt;=&lt;要修改成指定的数据&gt;,&lt;字段名2&gt;=&lt;要修改成指定的数据&gt; … ;<br><br> 例：update goods set id=0,name=’小明’;<br><br> 修改指定字段所有数据 注：此指令是将所有符合此字段的所有值修改成统一值</p></li><li><p>update &lt;表名&gt;<br> set &lt;字段名1&gt;=&lt;要修改成指定的数据&gt;,&lt;字段名2&gt;=&lt;要修改成指定的数据&gt; …<br> where &lt;指定范围的条件&gt;;<br></p><p> 例如：update goods<br> set id=0,price=20.0 where type=’书籍’;</p><p> 上面的意思是：将goods表中字段书籍中的一天数据中的id等于0，price(价格)等于20.0<br> 修改指定的数据</p></li><li><p>delete from &lt;表名&gt;;<br><br> 删除所有数据</p></li><li><p>delete from &lt;表名&gt; where &lt;指定范围的条件&gt;;<br><br> 例如：delete from goods where id&gt;3;<br> 上面的意思是删除goods表中id&gt;3的数据<br> 删除指定数据</p></li></ol><hr><h2 id="查询数据命令："><a href="#查询数据命令：" class="headerlink" title="查询数据命令："></a>查询数据命令：</h2><ol><li>select * from &lt;表名&gt;;<br>查询所有字段数据</li><li>select &lt; 乘号 || 字段名1,字段名2…….&gt; from &lt;表名&gt;;<br>例如：select name,id from goods;<br><br> 上面的意思是查询goods表中name和id字段的数据<br>   查询指定字段数据</li><li>select &lt; 乘号 || 字段名1,字段名2…….&gt; from &lt;表名&gt; where &lt;指定范围的条件&gt;;<br><br> 例如：select * from goods where id=3;<br><br> 上面的意思是查询goods表中id等于3的数据<br> 查询指定记录</li><li>select &lt; 乘号 || 字段名1,字段名2…….&gt; from &lt;表名&gt; where &lt;指定范围的条件1&gt; and  &lt;指定范围的条件2&gt;;<br>例如：select * from goods id=3 and price&gt;30;<br><br> 上面的意思是查询goods表中id=3且price(价格)大于30的数据<br> and关键字查询，需要符合所有条件才可以返回</li><li>select &lt;乘号 || 字段名1,字段名2…….&gt; from &lt;表名&gt; where &lt;指定范围的条件1&gt; or  &lt;指定范围的条件2&gt;;<br>例如：select * from goods id=3 or price&gt;30;<br><br> 上面的意思是查询goods表中id=3或者price(价格)大于30的数据<br> or关键字查询，只需要符合所有条件中的一个条件就可以返回</li><li>select &lt; 乘号 || 字段名1,字段名2…….&gt; from &lt;表名&gt; where &lt;字段名&gt; in (值1,值2,值3…….);<br>例如：select * from goods id in (1,3);<br><br> 上面的意思是查询goods表中id值为1和3的数据<br><br> in关键字查询，指定集合包括在括号中，值与值之间用括号分隔开</li><li>select &lt; 乘号 || 字段名1,字段名2…….&gt; from &lt;表名&gt; where &lt;字段名&gt; is null;<br>例如：select * from goods where price is null;<br><br> 上面的意思是查询goods表中price(价格)为null的数据<br><br> 查询空值</li><li>select distinct &lt;字段名&gt; from &lt;表名&gt;;<br><br> 查询结果不重复</li><li>select &lt; 乘号 || 字段名1,字段名2…….&gt; from &lt;表名&gt; where &lt;字段名&gt; between &lt;值1&gt; and &lt;值2&gt;;<br> <br>例如：select name,price from goods where id between 2.5 and 20;<br><br> 上面的意思是查询goods表中price(价格)2.5到30块钱的数据并且只显示商品名称和价格<br><br>   范围查询</li><li>select &lt; 乘号 || 字段名1,字段名2…….&gt; from &lt;表名&gt; where &lt;字段名&gt; like ‘%值1%’;<br>例如：select * from goods where name like ‘%糖%’;<br><br>上面的意思是查询goods表中name(商品名称)含有糖的所有数据<br><br>模糊查询<br><br><strong>通配符：</strong><br><br>‘%’：指可以匹配任何长度的字符，可以是1个也可以是多个<br><br>‘_’：指可以出现在匹配字符的任意位置，并且可以匹配任意数目的字符</li><li>select &lt; 乘号 || 字段名1,字段名2…….&gt; from &lt;表名&gt; order by 字段名1,字段名2 …..;<br>例如：select * from goods order by id,num;<br>上面的意思是查询goods表中num与id升序查询<br>排序查询</li><li>select &lt; 乘号 || 字段名1,字段名2…….&gt; from &lt;表名&gt; order by 字段名1 desc,字段名2;<br><br>例如：select * from goods order by id,desc,price;<br><br>上面的意思是查询goods表中id字段和price(价格)字段查询<br><br>降序查询(以上是多字符查询，如果只让一个字符降序查询那就直接desc后面加分号即可)</li><li>select &lt; 乘号 || 字段名1,字段名2…….&gt; from &lt;表名&gt; limit 起始位置,查询总记录条数;<br><br>例如：select * from goods limit 0,3;<br><br>上面的意思是查询goods表中从第一条查询(数据库默认是从0开始计算的),总共查询出来3条<br><br>限制结果查询</li></ol><h2 id="聚合函数和分组数据记录查询"><a href="#聚合函数和分组数据记录查询" class="headerlink" title="聚合函数和分组数据记录查询"></a>聚合函数和分组数据记录查询</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><h4 id="概括："><a href="#概括：" class="headerlink" title="概括："></a>概括：</h4><ol><li>count()函数计算表中的条数</li><li>sum()函数计算字段值的总和</li><li>avg()函数计算字段值的平均值</li><li>max()函数查询表中字段值的最大值</li><li>min()函数查询表中字段值的最小值</li><li>group_concat()函数显示每种类型包含的商品名称都显示出来</li></ol><h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><ol><li>select count(乘号 || 返回记录条数) from 表名;<br><br> 查询表中的条数</li><li>select sum(字段名) from 表名;<br><br> 查询字段值的总和</li><li>select &lt; 乘号 || 字段名1,字段名2…….&gt;,avg(字段名) from 表中 group by 分组规则;<br><br> 例如：select type,avg(price) from goods group by type;<br><br> 上面的意思是查询goods表中价格的平均值，只显示type(闪频名称)与平均值，使用type进行分组<br><br> <strong>group by</strong>的意思是用于分组查询</li><li>select max(字段名) from 表名;<br><br> 查询表中字段值的最大值</li><li>select min(字段名) from 表名;<br><br> 查询表中字段值的最小值</li></ol><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><ol><li>select &lt; 乘号 || 字段名1,字段名2…….&gt;,聚合函数 from 表名 group by 分组规则;<br>分组查询<br><br> 例如：select type,group_concat(name) from goods group by type;<br><br> 上面的意思是查询goods表中每种<strong>类型</strong>的<strong>商品名称</strong>都显示出来</li><li>select &lt; 乘号 || 字段名1,字段名2…….&gt;,聚合函数 from 表名 group by 分组规则 having 过滤规则(可以使用函数来过滤);<br>使用having过滤分组后的数据<br><br> select type,count(<strong>乘号表所有</strong>) from goods group by type having count(<strong>乘号表所有</strong>)&gt;1;<br><br> 上面的意思是将goods表中的记录按照type字段分组并统计每组的数量，(having count(<strong>乘号表所有</strong>)&gt;1)然后只取商品数量大于1的分组</li><li>select &lt; 乘号 || 字段名1,字段名2…….&gt;,聚合函数 from 表名 group by 分组规则1,分组规则2…;<br><br> 使用多个字段进行分组<br><br> 例如：select type,group_concat(name),count(name) from goods group by type,num;<br><br> 上面的意思是将goods表中的记录按照type和num字段进行分组并统计</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第2节：数据库常用命令&quot;&gt;&lt;a href=&quot;#第2节：数据库常用命令&quot; class=&quot;headerlink&quot; title=&quot;第2节：数据库常用命令&quot;&gt;&lt;/a&gt;第2节：数据库常用命令&lt;/h1&gt;&lt;h4 id=&quot;常用数据库命令集：&quot;&gt;&lt;a href=&quot;#常用数据库命令集</summary>
      
    
    
    
    <category term="MySQL" scheme="http://xrebirth.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://xrebirth.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据类型(03)</title>
    <link href="http://xrebirth.github.io/posts/5f8d3e42.html"/>
    <id>http://xrebirth.github.io/posts/5f8d3e42.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:02:31.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第3节：数据类型"><a href="#第3节：数据类型" class="headerlink" title="第3节：数据类型"></a>第3节：数据类型</h1><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>mysql支持所有标准sql数值数据类型。  这些类型包括严格数值数据类型(integer、smallint、decimal和numeric)，以及近似数值数据类型(float、real和double precision)。  关键字int是integer的同义词，关键字dec是decimal的同义词。  bit数据类型保存位字段值，并且支持myisam、memory、innodb和bdb表。  作为sql标准的扩展，mysql也支持整数类型tinyint、mediumint和bigint。下面的表显示了需要的每个整数类型的存储和范围。</p><p><img src="https://xuanxuanimages.oss-cn-beijing.aliyuncs.com/img/mysql.png" alt="数值类型"></p><h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><p>表示时间值的日期和时间类型为datetime、date、timestamp、time和year。每个时间类型有一个有效值范围和一个”零”值，当指定不合法的mysql不能表示的值时使用”零”值。timestamp类型有专有的自动更新特性，将在后面描述。</p><p><img src="https://xuanxuanimages.oss-cn-beijing.aliyuncs.com/img/2.png" alt="日期和时间类型"></p><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>字符串类型指char、varchar、binary、varbinary、blob、text、enum和set。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p><p><img src="https://xuanxuanimages.oss-cn-beijing.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210520230802.png" alt="字符串类型"></p><p>注意：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 char(30) 就可以存储 30 个字符。<br>char 和 varchar 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。<br>binary 和 varbinary 类似于 char 和 varchar，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。<br>blob 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 blob 类型：tinyblob、blob、mediumblob 和 longblob。它们区别在于可容纳存储范围不同。<br>有 4 种 text 类型：tinytext、text、mediumtext 和 longtext。对应的这 4 种 blob 类型，可存储的最大长度不同，可根据实际情况选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第3节：数据类型&quot;&gt;&lt;a href=&quot;#第3节：数据类型&quot; class=&quot;headerlink&quot; title=&quot;第3节：数据类型&quot;&gt;&lt;/a&gt;第3节：数据类型&lt;/h1&gt;&lt;h2 id=&quot;数值类型&quot;&gt;&lt;a href=&quot;#数值类型&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="MySQL" scheme="http://xrebirth.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://xrebirth.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Git基本使用(02)</title>
    <link href="http://xrebirth.github.io/posts/94e2c847.html"/>
    <id>http://xrebirth.github.io/posts/94e2c847.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:10:12.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git基本使用"><a href="#Git基本使用" class="headerlink" title="Git基本使用"></a>Git基本使用</h1><h3 id="个人日常Git的基本使用"><a href="#个人日常Git的基本使用" class="headerlink" title="个人日常Git的基本使用"></a>个人日常Git的基本使用</h3><h3 id="Git之间的关系："><a href="#Git之间的关系：" class="headerlink" title="Git之间的关系："></a>Git之间的关系：</h3><p><img src="https://xuanxuanimages.oss-cn-beijing.aliyuncs.com/img/1780672-20200222211257892-559749381.png"></p><h2 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h2><ol><li><p>在<strong>git客户端</strong>或者<strong>CMD命令行</strong>上执行,我们通过命令行进入本地项目目录下，然后执行执行下面的命令，<strong>或</strong>创建已新建好的项目文件，然后再执行下右击项目文件点击打开Git Bash Here，然后执行下面的命令。</p><blockquote><p>git init    初始化git仓库</p><p>(如果发现此项目文件夹下出现一个git的文件<strong>隐藏文件夹</strong>就说明初始化成功了)</p></blockquote></li><li><p>与github仓库连接。</p><blockquote><p>继续在git gash或者CMD命令行上执行以下命令：</p><p>git remote add origin&lt;github/码云项目sh地址&gt;</p><p>(一般这个命令执行成功以后本地仓库的项目便已经同远端仓库的项目保持同步了。不妨登录github/码云上查看)</p></blockquote><p> <strong>注意：前提github/码云</strong>上已经创建远程仓库。</p></li></ol><h2 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h2><ul><li>找到你刚才在记录下的远端仓库的地址,或者再次登录以下界面去复制远端仓库地址;</li></ul><blockquote><p>然后执行一下命令行:</p><p>git clone&lt;项目ssh地址&gt;</p><p><strong>注意：使用cmd/git打开使用gitclone，建议已经创建好项目文件或者cmd中已经到本地项目文件地址。</strong></p></blockquote><h2 id="提交文件到暂存区、本地仓库"><a href="#提交文件到暂存区、本地仓库" class="headerlink" title="提交文件到暂存区、本地仓库"></a>提交文件到暂存区、本地仓库</h2><ul><li>将上述步骤完成以后,我们便可以初步使用git了。可以执行以下命令：</li></ul><blockquote><p>git add -u</p><p>将文件的修改、文件的删除，添加到暂存区。<br>git add .</p><p>将文件的修改，文件的新建，添加到暂存区。<br>git add -A</p><p>将文件的修改，文件的删除，文件的新建，添加到暂存区。</p><p><strong>建议使用git add -Ajiany命令</strong></p></blockquote><blockquote><p>git commit 无法退出</p><p>　　i 插入文字的命令。窗口最一开始打开时是不能输入的。按一下 i 就可以开始输入我们的提交信息啦！</p><p>　　输入完了怎么保存退出呢？</p><p>　　先按一下Esc，退出输入状态。</p><p>　　w 保存命令。将我们输入的提交信息保存。保存完之后，</p><p>　　q 退出窗口。就回到我们最开始的命令界面啦。</p><p>git commit -m “提交信息”</p><p><strong>建议使用git commit -m “提交信息”命令</strong></p></blockquote><blockquote><p>git status</p><p>查看<strong>文件/文件夹在工作区，暂存区</strong>的状态</p></blockquote><h2 id="将本地仓库代码提交到github-码云上"><a href="#将本地仓库代码提交到github-码云上" class="headerlink" title="将本地仓库代码提交到github/码云上"></a>将本地仓库代码提交到github/码云上</h2><ul><li>提交代码命令：</li></ul><blockquote><p>git pull origin main<br>拉取到本地main(主分支)</p><p>git push origin main<br>推送到远程仓库main(主分支)</p><p>git pull</p><p>拉取远程仓库代码到本地</p><p>git push</p><p>将本地仓库推送到远程仓库</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git基本使用&quot;&gt;&lt;a href=&quot;#Git基本使用&quot; class=&quot;headerlink&quot; title=&quot;Git基本使用&quot;&gt;&lt;/a&gt;Git基本使用&lt;/h1&gt;&lt;h3 id=&quot;个人日常Git的基本使用&quot;&gt;&lt;a href=&quot;#个人日常Git的基本使用&quot; class=&quot;</summary>
      
    
    
    
    <category term="Git" scheme="http://xrebirth.github.io/categories/Git/"/>
    
    
    <category term="Git" scheme="http://xrebirth.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git安装及配置(01)</title>
    <link href="http://xrebirth.github.io/posts/161b8ec9.html"/>
    <id>http://xrebirth.github.io/posts/161b8ec9.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:09:47.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git安装及配置"><a href="#Git安装及配置" class="headerlink" title="Git安装及配置"></a>Git安装及配置</h1><p><img src="https://xuanxuanimages.oss-cn-beijing.aliyuncs.com/img/Git_picture.jpg"></p><h2 id="Git概述："><a href="#Git概述：" class="headerlink" title="Git概述："></a>Git概述：</h2><p>​    Git是一个分布式开发的软件，它是由多人协作共同完成一个项目的软件，同时<strong>Github</strong>也是一个全球最大的开源社区，拥有着丰富的开源项目资源。</p><h2 id="Git个人用处："><a href="#Git个人用处：" class="headerlink" title="Git个人用处："></a>Git个人用处：</h2><ol><li>学会Git以后可以在任何地方，直接调用自己写的Code。</li><li>同时如果后期需要多人开发也可以直接协同开发，不需要后期在学了。</li><li><strong>github</strong>上拥有众多的开源项目，可以自己学习以及实践一些项目。</li></ol><h2 id="GIt安装："><a href="#GIt安装：" class="headerlink" title="GIt安装："></a>GIt安装：</h2><ol><li>安装Git可以直接去官网下载，也可以直接从软件管家中下载。</li><li>安装完毕，直接点击安装Next即可。（ps：我也不懂英文）…</li></ol><h2 id="Git基本配置"><a href="#Git基本配置" class="headerlink" title="Git基本配置"></a>Git基本配置</h2><ol><li><p>新建一个项目，右击点击该项目的文件夹，点击Git Bash Here。</p></li><li><p>新电脑初次打开需要配置Git的邮箱和用户名，用于Git识别此电脑身份。</p></li><li><p>配置邮箱和用户名。</p><ul><li>git config –global user.name ‘用户名称’<br>  设置用户名</li><li>git config –global user.email ‘登录邮箱’<br>  设置邮箱</li><li>git config user.name<br>  查看已用户名</li><li>git config user.email<br>  查看已邮箱</li><li>git config –list<br>  查看Git设置列表</li></ul></li><li><p>配置公私钥</p><ol><li><p>生成密钥命令：</p><p> ssh-keygen -t rsa -C “邮箱@qq.com”<br> 生成公钥</p><p> cat ~/.ssh/id_rsa.pub<br> 查看公钥</p></li><li><p><strong>公钥的作用：</strong></p><p> 很多服务器都是需要认证的，ssh认证是其中的一种。在客户端生成公钥，把生成的公钥添加到服务器，你以后连接服务器就不用每次都输入用户名和密码了。</p><p> 很多git服务器都是用ssh认证方式，你需要把你生成的公钥发送给代码仓库管理员，让他给你添加到服务器上，你就可以通过ssh自由的拉取和提交代码了。</p></li><li><p>配置公/私钥<br> 输入 ssh-keygen -t rsa -C “上面配置的邮箱”执行这条命令会提示文件保存路径，可以直接按Enter，然后提示输入 passphrase（密码），输入两次（可以不输直接按两次Enter），然后会在 .ssh 目录生产两个文件：id_rsa和id_rsa.pub用记事本打开.ssh目录下的id_rsa.pub公钥文件，复制里面的内容；也可以直接在git中输入<strong>cat ~/.ssh/id_rsa.pub</strong>直接查看公钥。</p></li></ol></li><li><p>复制公钥，打开<strong>Github</strong>或者<strong>码云</strong>配置相应的公钥匙。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git安装及配置&quot;&gt;&lt;a href=&quot;#Git安装及配置&quot; class=&quot;headerlink&quot; title=&quot;Git安装及配置&quot;&gt;&lt;/a&gt;Git安装及配置&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://xuanxuanimages.oss-cn-beijin</summary>
      
    
    
    
    <category term="Git" scheme="http://xrebirth.github.io/categories/Git/"/>
    
    
    <category term="Git" scheme="http://xrebirth.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git基本常用命令集(03)</title>
    <link href="http://xrebirth.github.io/posts/e80658dd.html"/>
    <id>http://xrebirth.github.io/posts/e80658dd.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:10:28.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git基本常用命令集"><a href="#Git基本常用命令集" class="headerlink" title="Git基本常用命令集"></a>Git基本常用命令集</h1><h2 id="基本常用命令："><a href="#基本常用命令：" class="headerlink" title="基本常用命令："></a>基本常用命令：</h2><p>git init    初始化git仓库</p><p>如果第一次与仓库连接使用以下命令：</p><ol><li>git remote add origin &lt;github远程仓库地址&gt; 将本地仓库与远程仓库连接</li><li> git branch -M main 将主分支名称master修改为main</li><li>git push -u origin main  推送远程仓库</li></ol><p>本地仓库命令：</p><ol><li><p>将所有文件添加到暂存区<br> git add .    </p></li><li><p>提交到本地仓库<br> git commit -m “提交信息”    </p></li><li><p>推送到远程仓库<br> git push</p></li></ol><p>克隆仓库命令：</p><ol><li>克隆当前仓库：<br> git clone &lt;项目ssh地址&gt;    </li><li>克隆所有仓库：<br> 待学习…</li></ol><h2 id="分支常用命令："><a href="#分支常用命令：" class="headerlink" title="分支常用命令："></a>分支常用命令：</h2><ol><li>切换分支 git checkout 分支名</li><li>删除分支 git branch -d 分支名</li><li>查看本地分支 git branch</li><li>查看远程分支 git branch -a</li><li>创建分支 git branch 分支名</li><li>创建+切换分支 git checkout -b</li><li>删除分支 git breach -d 分支名</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git基本常用命令集&quot;&gt;&lt;a href=&quot;#Git基本常用命令集&quot; class=&quot;headerlink&quot; title=&quot;Git基本常用命令集&quot;&gt;&lt;/a&gt;Git基本常用命令集&lt;/h1&gt;&lt;h2 id=&quot;基本常用命令：&quot;&gt;&lt;a href=&quot;#基本常用命令：&quot; class</summary>
      
    
    
    
    <category term="Git" scheme="http://xrebirth.github.io/categories/Git/"/>
    
    
    <category term="Git" scheme="http://xrebirth.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Github实用小技巧(04)</title>
    <link href="http://xrebirth.github.io/posts/93839e01.html"/>
    <id>http://xrebirth.github.io/posts/93839e01.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:11:26.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github实用小技巧"><a href="#Github实用小技巧" class="headerlink" title="Github实用小技巧"></a>Github实用小技巧</h1><ol><li>使用技巧<ul><li>例如github网址：<a href="https://github.com/Xrebirth/JavaExercise">https://github.com/Xrebirth/JavaExercise</a><br>  在<a href="https://github后面加上1s会变成vscode界面/">https://github后面加上1s会变成vscode界面</a><br>  修改后效果：<a href="https://github1s.com/Xrebirth/JavaExercise">https://github1s.com/Xrebirth/JavaExercise</a><br>  缺点：必须开科学上网才可以访问到。</li></ul></li><li>使用技巧<ul><li><code>待更新...</code></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Github实用小技巧&quot;&gt;&lt;a href=&quot;#Github实用小技巧&quot; class=&quot;headerlink&quot; title=&quot;Github实用小技巧&quot;&gt;&lt;/a&gt;Github实用小技巧&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;使用技巧&lt;ul&gt;
&lt;li&gt;例如github网址：&lt;a h</summary>
      
    
    
    
    <category term="Github" scheme="http://xrebirth.github.io/categories/Github/"/>
    
    
    <category term="Github" scheme="http://xrebirth.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>git bash 常用命令(05)</title>
    <link href="http://xrebirth.github.io/posts/bdcfb600.html"/>
    <id>http://xrebirth.github.io/posts/bdcfb600.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:11:49.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-bash-常用命令"><a href="#git-bash-常用命令" class="headerlink" title="git bash 常用命令"></a>git bash 常用命令</h1><ol><li>cd : change directory的简写，改变目录的意思，就是切换到哪个目录下， 如 cd e:\fff  切换 E 盘下面的fff 目录。<br> 当我们用cd 进入文件夹时,我们可以使用 通配符*, cd f*,  如果E盘下只有一个f开头的文件夹,它就会进入到这个文件夹.</li><li>cd .. 回退到上一个目录。我们在写js,或css时，我们引入文件时，.. 表示的就是上一个目录, 所以 cd .. 回退到上一个目录就很好理解了。注意，cd 和两个点点..之间有一个空格,  </li><li>pwd : print working directory, 打印工作目录，它会显示我们当前所在的目录路径。</li><li>ls: list, 列出当前目录中的所有文件，   只不过ll(两个ll)列出的内容更为详细。</li><li>touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</li><li>rm:  删除一个文件, rm index.js 就会把index.js文件删除.</li><li>mkdir: 新建一个目录,就是新建一个文件夹. 如mkdir src 新建src 文件夹.</li><li>rm -r :  删除一个文件夹， r (recusive 是递归的意思)， 删除用的就是递归，先删除文件夹里面的内容，再删除文件夹。 rm -r src 删除src目录。 </li><li>mv 移动文件, mv index.html src  index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下.</li><li>reset 清屏，把git bash命令窗口中的所有内容清空。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;git-bash-常用命令&quot;&gt;&lt;a href=&quot;#git-bash-常用命令&quot; class=&quot;headerlink&quot; title=&quot;git bash 常用命令&quot;&gt;&lt;/a&gt;git bash 常用命令&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;cd : change director</summary>
      
    
    
    
    <category term="Git" scheme="http://xrebirth.github.io/categories/Git/"/>
    
    
    <category term="Git" scheme="http://xrebirth.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Table标签(01)</title>
    <link href="http://xrebirth.github.io/posts/2e463a55.html"/>
    <id>http://xrebirth.github.io/posts/2e463a55.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:06:56.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1节：Table标签"><a href="#第1节：Table标签" class="headerlink" title="第1节：Table标签"></a>第1节：Table标签</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100%<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100px<span class="token punctuation">"</span></span> <span class="token attr-name">cellpadding</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10px<span class="token punctuation">"</span></span> <span class="token attr-name">cellspacing</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>15px<span class="token punctuation">"</span></span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1px<span class="token punctuation">"</span></span> <span class="token attr-name">bgcolor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>white<span class="token punctuation">"</span></span> <span class="token attr-name">bordercolor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>blue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>caption</span><span class="token punctuation">></span></span>表格标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>caption</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span> <span class="token attr-name">aria-rowcount</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span> <span class="token attr-name">colspan</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name">bgcolor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aqua<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>合并2行<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span> <span class="token attr-name">rowspan</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name">bgcolor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#ccc<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>合并2列<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="table标签属性："><a href="#table标签属性：" class="headerlink" title="table标签属性："></a>table标签属性：</h2><ul><li><code>width</code>：长度</li><li><code>height</code>：高度</li><li><code>cellspacing</code>：规定单元边沿与单元内容之间的空间，用以像素(px)或百分比(%)</li><li><code>cellpadding</code>：规定单元边沿与其内容之间的空白，用以像素(px)或百分比(%)</li><li><code>border</code>：边框</li><li><code>bordercolor</code>：边框颜色</li><li><code>bgcolor</code>：规定表格单元格的背景颜色</li><li>**<code>colspan</code>**：合并行，输入值：合并几行</li><li>**<code>rowspan</code>**：合并列，输入值：合并几列</li></ul><h2 id="table的子集标签："><a href="#table的子集标签：" class="headerlink" title="table的子集标签："></a>table的子集标签：</h2><ul><li><code>caption</code>：表格标题</li><li><code>th</code>：表头 (<strong>表头与列不同的是表头文字自动加粗文字居中</strong>)</li><li><code>tr</code>：行</li><li><code>td</code>：列</li></ul><p><code>待补充...</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第1节：Table标签&quot;&gt;&lt;a href=&quot;#第1节：Table标签&quot; class=&quot;headerlink&quot; title=&quot;第1节：Table标签&quot;&gt;&lt;/a&gt;第1节：Table标签&lt;/h1&gt;&lt;h2 id=&quot;格式&quot;&gt;&lt;a href=&quot;#格式&quot; class=&quot;head</summary>
      
    
    
    
    <category term="HTML" scheme="http://xrebirth.github.io/categories/HTML/"/>
    
    
    <category term="HTML" scheme="http://xrebirth.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Table总结</title>
    <link href="http://xrebirth.github.io/posts/c888fdae.html"/>
    <id>http://xrebirth.github.io/posts/c888fdae.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:07:23.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第2节：Table总结"><a href="#第2节：Table总结" class="headerlink" title="第2节：Table总结"></a>第2节：Table总结</h1><h2 id="Table标签属性总结："><a href="#Table标签属性总结：" class="headerlink" title="Table标签属性总结："></a>Table标签属性总结：</h2><ul><li><code>&lt;tr&gt;</code>不能设置width，但是可以设置height</li><li>如果一行中每个<code>&lt;td&gt;</code>或者<code>&lt;th&gt;</code>每个元素长度不一试着在<code>&lt;table&gt;</code>加上<code>table-layout:fixed</code>注意：这个是style样式表</li></ul><h2 id="a-标签更改字体以及去掉下划线："><a href="#a-标签更改字体以及去掉下划线：" class="headerlink" title="**a**标签更改字体以及去掉下划线："></a>**<code>a</code>**标签更改字体以及去掉下划线：</h2><pre class="line-numbers language-css"><code class="language-css"><span class="token property">color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>    // 更改字体颜色<span class="token property">text-decoration</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span>    // 去掉下划线<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>待补充...</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第2节：Table总结&quot;&gt;&lt;a href=&quot;#第2节：Table总结&quot; class=&quot;headerlink&quot; title=&quot;第2节：Table总结&quot;&gt;&lt;/a&gt;第2节：Table总结&lt;/h1&gt;&lt;h2 id=&quot;Table标签属性总结：&quot;&gt;&lt;a href=&quot;#Table</summary>
      
    
    
    
    <category term="HTML" scheme="http://xrebirth.github.io/categories/HTML/"/>
    
    
    <category term="HTML" scheme="http://xrebirth.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>继承(10)</title>
    <link href="http://xrebirth.github.io/posts/5f8d3e42.html"/>
    <id>http://xrebirth.github.io/posts/5f8d3e42.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:42:54.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ol><li><p>继承是面向对象三大特征之一,三大特征分别是:封装、继承、多态</p></li><li><p>继承”基本”的作用是:代码复用。但是继承最”重要”的作用是:有了继承才有了以后”方法的覆盖”和”多态机制”。</p></li><li><p>继承语法格式:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span>修饰符列表<span class="token punctuation">]</span> c1ass 类名 <span class="token keyword">extends</span> 父类名<span class="token punctuation">{</span>类体 <span class="token operator">=</span> 属性 <span class="token operator">+</span> 方法<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 语法声明类中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>java语言当中的继承只支持单继承,一个类不能同时继承很多类,只能继承一个类。在C++中支持多继承。</p></li><li><p>关于继承中的一些术语:</p></li><li><p>B类继承A类,其中:</p><ul><li>A类称为: 父类、基类、超类、 superclass</li><li>B类称为: 子类、派生类、 subclass</li></ul></li><li><p>在java语言当中子类继承父类都继承哪些数据呢?</p><ul><li>私有的不支持继承</li><li>构造方法不支持继承</li><li>其它数据都可以被继承</li></ul></li><li><p>虽然java语言当中只支持单继承,但是一个类也可以间接继承其它类,例如</p><ul><li>C extends B()</li><li>B extends A()</li><li>A extends T()</li><li><strong>c直接继承B类,但是c类间接继承A类。</strong></li></ul></li><li><p>Java语言中假设一个类没有显示的继承任何类,该类默认继承 JavaSE库当中提供的Java.ang. Object类。</p></li><li><p>注意：Java中任何任何一个类都有Object类的特征.</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;继承是面向对象三大特征之一,三大特征分别是:封装、继承、多态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;继承”基本”的作用是:代码</summary>
      
    
    
    
    <category term="Java" scheme="http://xrebirth.github.io/categories/Java/"/>
    
    
    <category term="Java基础" scheme="http://xrebirth.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>多态(Polymorphism)(11)</title>
    <link href="http://xrebirth.github.io/posts/5f8d3e42.html"/>
    <id>http://xrebirth.github.io/posts/5f8d3e42.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:42:59.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态(Polymorphism)"></a>多态(Polymorphism)</h1><h3 id="关于java语言当中的多态语法机制-【只是多态的基础语法-多态的作用在后续的例子中讲解。】"><a href="#关于java语言当中的多态语法机制-【只是多态的基础语法-多态的作用在后续的例子中讲解。】" class="headerlink" title="关于java语言当中的多态语法机制:【只是多态的基础语法,多态的作用在后续的例子中讲解。】"></a>关于java语言当中的多态语法机制:【只是多态的基础语法,多态的作用在后续的例子中讲解。】</h3><ol><li><p>Anima1、Cat、Bird三个类之间的关系:<br> Cat继承 Anima<br> Bird维承 Anima<br> Cat和Bird之间没有任何继承关系</p></li><li><p>面向对象三大特征:封装、继承、多态</p></li><li><p>关于多态中涉及到的几个概念:</p></li></ol><ul><li><p>向上转型(upcasting)</p><p>子类型—-&gt;父类型<br>又被称为:自动类型转换。</p><pre class="line-numbers language-java"><code class="language-java">Animal animal1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 子转父类 向上转型</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>向下转型(downcasting)</p><p>父类型—-&gt;子类型<br>又被称为:强制类型转换。【需要加强制类型转换符】</p><pre class="line-numbers language-java"><code class="language-java">Cat cat <span class="token operator">=</span> <span class="token punctuation">(</span>Cat<span class="token punctuation">)</span> animal1<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 父类转子类 向下转型</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><ol start="4"><li><p>需要记忆:<br> 无论是向上转型还是向下转型,两种类型之间必须要有继承关系。<br> 没有继承关系,程序是无法编译通过的。</p></li><li><p>注意：</p></li><li><p>java程序永远都分为编译阶段和运行阶段。</p></li><li><p>先分析编译阶段,再分析运行阶段,编译无法通过,根本是无法运行的。</p></li><li><p>编译阶段编译器检查a2这个引用的数据类型为 Anima1,由于 Anima1.c1ass</p><p> 字节码当中有move()方法,所以编译通过了。这个过程我们成为静态绑定,编译阶段绑定。<br> 只有静态绑定成功之后才有后续的运行。</p></li><li><p>在程序运行阶段,JV唯堆内存当中真实创建的对象是cat对象,那么以下程序在运行阶段一定会调用cat对象的move()方法,此时发生了程序的动态绑定,运行阶段绑定。</p></li><li><p>无论是cat类有没有重写move方法,运行阶段一定调用的是cat对象的move方法,因为底层</p><p> 真实对象就是cat对象。</p></li><li><p>父类型引用指向子类型对象这种机制导致程序存在编译阶段绑定和运行阶段绑定两种不同的形态/状态,这种机制可以成为一种多态语法机制。</p></li><li><p>instanceof运算符(返回boolean类型)</p><pre class="line-numbers language-java"><code class="language-java">        Animal animal1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 子转父类 向上转型</span>        Dog dog <span class="token operator">=</span> <span class="token punctuation">(</span>Dog<span class="token punctuation">)</span> animal1<span class="token punctuation">;</span>        dog<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 以上会编译报错：cannot be cast to class (cat类不能强制转换为dog类)         * 原因：         * 1. 编译未报错：         *  - 编译检测时候当前Animal里面包含Dog类所以语法正确         * 2. 运行错误报错：         *  - 运行时候由于堆内存中是Cat类由于Cat与Dog不是继承关系，所以无法完成向下转型         * 3. 解决方法：         *  - Sun公司给出了一个运算符叫做：instanceof         *  - 语法：引用 instanceof 类名   --------> 返回值：Boolean          */</span><span class="token comment" spellcheck="true">//         解决办法</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>animal1 <span class="token keyword">instanceof</span> <span class="token class-name">Dog</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 当animal的堆内存中存储的是dog对象时执行</span>            Dog dog <span class="token operator">=</span> <span class="token punctuation">(</span>Dog<span class="token punctuation">)</span> animal1<span class="token punctuation">;</span>            animal1<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>animal1 <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 当animal的堆内存中存储的是cat对象时执行</span>            Cat cat <span class="token operator">=</span> <span class="token punctuation">(</span>Cat<span class="token punctuation">)</span> animal1<span class="token punctuation">;</span>            animal1<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 这样有效的避免了编译报错：cannot be cast to class</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>总结：</p><ol><li>如果创建了一个B对象，且B类继承自A类，如果B类想使用A类中方法</li></ol><p>   这种情况使用向上转型(upcasting)</p><ol><li>如果创建了一个B对象，且B类继承自A类，且B类现在已经向上转型了，但是现在向调用子类方法</li></ol><p>   这种情况使用向下转型(downcasting)</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多态-Polymorphism&quot;&gt;&lt;a href=&quot;#多态-Polymorphism&quot; class=&quot;headerlink&quot; title=&quot;多态(Polymorphism)&quot;&gt;&lt;/a&gt;多态(Polymorphism)&lt;/h1&gt;&lt;h3 id=&quot;关于java语言当中的</summary>
      
    
    
    
    <category term="Java" scheme="http://xrebirth.github.io/categories/Java/"/>
    
    
    <category term="Java基础" scheme="http://xrebirth.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>方法的覆盖(10.1)</title>
    <link href="http://xrebirth.github.io/posts/5f8d3e42.html"/>
    <id>http://xrebirth.github.io/posts/5f8d3e42.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:42:50.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法的覆盖-override"><a href="#方法的覆盖-override" class="headerlink" title="方法的覆盖(override)"></a>方法的覆盖(override)</h1><ol><li><p>语法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 父类</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"动物在跑步！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bird</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 子类</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"鸟在飞行！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Parrot</span> <span class="token keyword">extends</span> <span class="token class-name">Bird</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 继承于Bird</span>    <span class="token comment" spellcheck="true">// 继承Bird中的方法</span>    <span class="token comment" spellcheck="true">// 由于Bird继承于Animal但是Bird中自身又重写了action所以Parrot类直接继承于Bird方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"鹦鹉在学人话..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnimalTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * 以下是直接重写祖类中的方法         */</span>        <span class="token comment" spellcheck="true">// Animal父类中的方法</span>        Animal animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        animal<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// bird继承Animal中action方法并重写action方法</span>        Bird bird <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bird</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bird<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 以下是间接继承子类中的方法         */</span>        <span class="token comment" spellcheck="true">// 由于Bird继承于Animal但是Bird中自身又重写了action所以Parrot类直接继承于Bird方法</span>        Parrot parrot <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parrot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        parrot<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>方法的覆盖又被称为方法重写，英语单词: override【官方的】/overwrite</p></li><li><p>什么时候使用方法重写?</p><ul><li>当父类中的方法已经无法满足当前子类的业务需求,</li><li>子类有必要将父类中继承过来的方法进行重新编写,</li><li>这个重新编写的过程称为方法重写/方法覆盖。</li></ul></li><li><p>什么条件满足之后方法会发生重写呢?【代码满足什么条件之后,就构成方法的覆盖呢?】</p><ul><li><p>方法重写发生在具有继承关系的父子类之间</p></li><li><p>方法重写的时候:</p><p>  <strong>返回值类型相同</strong></p><p>  <strong>方法名相同</strong></p><p>  <strong>形参列表相同</strong></p></li><li><p>访问权限不能更低,可以更高</p></li><li><p>抛出异常不能更多,可以更少。【异常之后才能解释】</p></li></ul></li><li><p>建议方法重写的时候尽量复制粘贴,不要编写,容易出错,导致没有产生覆盖</p></li><li><p>注意：</p><ul><li>私有方法不能继承,所以不能覆盖</li><li>构造方法不能继承,所以不能要盖</li><li>静态方法不存在覆盖【多态之后解释】</li><li>覆盖只针对方法,不谈属性</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;方法的覆盖-override&quot;&gt;&lt;a href=&quot;#方法的覆盖-override&quot; class=&quot;headerlink&quot; title=&quot;方法的覆盖(override)&quot;&gt;&lt;/a&gt;方法的覆盖(override)&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;语法：&lt;/p&gt;
&lt;pr</summary>
      
    
    
    
    <category term="Java" scheme="http://xrebirth.github.io/categories/Java/"/>
    
    
    <category term="Java基础" scheme="http://xrebirth.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>final修饰符(12)</title>
    <link href="http://xrebirth.github.io/posts/5f8d3e42.html"/>
    <id>http://xrebirth.github.io/posts/5f8d3e42.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:43:03.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h1><h2 id="关于java语言当中final关键字"><a href="#关于java语言当中final关键字" class="headerlink" title="关于java语言当中final关键字:"></a>关于java语言当中final关键字:</h2><ol><li><p>final是个关键字,表示”最终的，不可变的”</p></li><li><p>final修饰的类无法被继承</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">class</span>  <span class="token class-name">Animal</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*// 编译报错class Cat extends Animal {}*/</span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">//正确写法(Cat无法继承Animal)：</span><span class="token keyword">class</span> <span class="token class-name">Cat</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>final修饰的方法无法被重写/覆盖</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">a</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HelloWold！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">b</span> <span class="token keyword">extends</span> <span class="token class-name">a</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 'b()' 无法重写 'study_exercise.objectexercise.exercisefinal.a' 中的 'b()'；重写的方法为 final</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>final修饰的变量一旦之后,不可重新赋值【不可二次赋值】</p><pre class="line-numbers language-java"><code class="language-java">        <span class="token comment" spellcheck="true">// 第一种写法</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// a = 15; // 无法将值赋给 final 变量 'a'</span>        <span class="token comment" spellcheck="true">// 第二种写法：</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span>        b<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>final修饰的实例变量：</p><ul><li><p>综合考虑，java语言最终规定实例变量使用final修饰之后,必须手动赋值,不能采用系统默认值。</p></li><li><p>因为默认构造函数在构造方法时候会将成员变量赋值所以Sun公司综合考虑让开发人员自行赋值，否则会编译错误！</p></li><li><p>两种写法：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 第一种写法：</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第二种写法：</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>b<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**        总结以上两种写法：     * 第一种写法：     *  - 直接将成员变量直接赋值给了a，但是程序执行这句话实际是在构造函数中执行进行赋值的.     * 第二种写法：     *  - 直接在构造函数中赋值     *  总结：     *  以上两种情况其实在程序运行过程中都一样，只不过一个直接赋值一个写在构造函数中.     */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>final修饰的引用,一旦指向某个对象之后,不能再指向其它对象,那么被指向的对象无法被垃圾回收器回收。<br> 注意：<strong>final修饰的引用虽然指向某个对象之后不能指向其它对象,但是所指向的对象内部的内存是可以被修改的。</strong><br> 例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 加final实例化对象</span>        <span class="token keyword">final</span> Animal animal1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// animal1 = new Animal(20); // 编译报错：一旦使用final创建对象不能，不能指向其他对象</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>animal1<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        animal1<span class="token punctuation">.</span>a<span class="token operator">=</span><span class="token number">2300</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>animal1<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 总结：         * final修饰的引用虽然指向某个对象之后不能指向其它对象,但是所指向的对象内部的内存是可以被修改的。         */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>final用法之常量的使用：</p><p> <strong>常量的定义语法格式:</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> 类型 常量名 <span class="token operator">=</span> 值<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 提示：Java规范中要求所有常量的名字全部大写,每个单词之问使用下划线_连接</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;final修饰符&quot;&gt;&lt;a href=&quot;#final修饰符&quot; class=&quot;headerlink&quot; title=&quot;final修饰符&quot;&gt;&lt;/a&gt;final修饰符&lt;/h1&gt;&lt;h2 id=&quot;关于java语言当中final关键字&quot;&gt;&lt;a href=&quot;#关于java语言当中f</summary>
      
    
    
    
    <category term="Java" scheme="http://xrebirth.github.io/categories/Java/"/>
    
    
    <category term="Java基础" scheme="http://xrebirth.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>package、import的使用(13)</title>
    <link href="http://xrebirth.github.io/posts/5f8d3e42.html"/>
    <id>http://xrebirth.github.io/posts/5f8d3e42.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:43:07.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="package、import的使用"><a href="#package、import的使用" class="headerlink" title="package、import的使用"></a>package、import的使用</h1><h4 id="关于Java语言当中的包机制"><a href="#关于Java语言当中的包机制" class="headerlink" title="关于Java语言当中的包机制"></a>关于Java语言当中的包机制</h4><ol><li><p>包又称为 <code>package</code>，Java中引入 <code>package</code>这种语法机制主要是为了方便程序的管理<br> 不同功能的类被分门别类放到不同的软件包当中,查找比较方便,管理比较方便,易维护</p></li><li><p>定义 package</p><ul><li><p>在Java源程序的第一行上编写package语句。</p></li><li><p>package只能编写一个语句。</p></li><li><p>语法结构:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> 包名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>包名的命名规范:</p><ul><li><p>公司域名倒序+项目名+模块名+功能名;</p></li><li><p>采用这种方式重名的几率较低。因为公司域名具有全球唯一性</p></li><li><p>例如：</p><blockquote><p>com.bjpowernode.oauser.service;<br>org.apache.tomcat.core;</p></blockquote></li></ul></li><li><p>包名要求全部小写,包名也是标识符,必须遵守标识符的命名规则</p></li><li><p>一个包将来对应的是一个目录</p></li><li><p>使用package手动编译及运行Java：</p><ul><li><p>使用<code>package</code>机制之后，类名不在是原来的类名了，类名会变成java文件中定义的<code>package</code>路径</p></li><li><p>编译：javac java源文件路径 (在硬盘上生成一个class文件)</p></li><li><p>手动方式创建Java的package设置的目录，将java字节码文件放到java设置的package目录</p></li><li><p>运行：Java package路径</p></li><li><p>另一种方式(编译+运行)</p><ul><li><p>编译：</p><p>  javac -d 编译之后存放的路径 java源文件路径</p></li><li><p>例如：将F:\Hello World.java文件编译到C:\目录下</p><p>  javac -d C:\ F:\Hello World.java</p></li><li><p>java -d . <em>.java</em></p><p>  将当前的路径中*.java(所有含后缀名java文件)编译之后存放到当前文件目录下</p></li><li><p>运行JVM的类加载器ClassLoader默认从当前路径下加载。<br>  保证先切换到com所在的路径在执行</p></li></ul></li></ul></li><li><p><strong>import</strong>的使用</p><ul><li><p>什么时候使用<code>import</code></p><p>  想要调用一个类但是这个类，并且不在同一个包下的时候，需要使用 <code>import</code>进行引入</p></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;package、import的使用&quot;&gt;&lt;a href=&quot;#package、import的使用&quot; class=&quot;headerlink&quot; title=&quot;package、import的使用&quot;&gt;&lt;/a&gt;package、import的使用&lt;/h1&gt;&lt;h4 id=&quot;关于Jav</summary>
      
    
    
    
    <category term="Java" scheme="http://xrebirth.github.io/categories/Java/"/>
    
    
    <category term="Java基础" scheme="http://xrebirth.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>访问控制权限修饰符(14)</title>
    <link href="http://xrebirth.github.io/posts/5f8d3e42.html"/>
    <id>http://xrebirth.github.io/posts/5f8d3e42.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:43:11.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="访问控制权限修饰符"><a href="#访问控制权限修饰符" class="headerlink" title="访问控制权限修饰符"></a>访问控制权限修饰符</h1><ol><li>访问控制权限修饰符来控制元素的访问范围</li><li>访问控制权限修饰符：</li></ol><table><thead><tr><th>修饰符</th><th>权限解释</th></tr></thead><tbody><tr><td>public(公共的)</td><td>表示公共的公开的，可以在任何位置访问</td></tr><tr><td>protected (受保护的)</td><td>相同包内可以访问，子类也可以访问</td></tr><tr><td>缺省(不写修饰符)</td><td>相同包内可以访问</td></tr><tr><td>private(私人的)</td><td>表示私人，只能在本类中访问</td></tr></tbody></table><ol><li><p>访问控制权限修饰符可以修饰类、内部类、变量、方法…..等</p></li><li><p>修饰符的范围：</p><p> public &gt; protected &gt; 缺省(不写修饰符) &gt; public</p></li></ol><p><strong>注意</strong>：类只能采用<strong>public和缺省</strong>的修饰符进行修饰。【<strong>内部类除外</strong>】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;访问控制权限修饰符&quot;&gt;&lt;a href=&quot;#访问控制权限修饰符&quot; class=&quot;headerlink&quot; title=&quot;访问控制权限修饰符&quot;&gt;&lt;/a&gt;访问控制权限修饰符&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;访问控制权限修饰符来控制元素的访问范围&lt;/li&gt;
&lt;li&gt;访问控制权限修</summary>
      
    
    
    
    <category term="Java" scheme="http://xrebirth.github.io/categories/Java/"/>
    
    
    <category term="Java基础" scheme="http://xrebirth.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>单例模式(15)</title>
    <link href="http://xrebirth.github.io/posts/5f8d3e42.html"/>
    <id>http://xrebirth.github.io/posts/5f8d3e42.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:43:16.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式-singleton-pattern"><a href="#单例模式-singleton-pattern" class="headerlink" title="单例模式(singleton pattern)"></a>单例模式(singleton pattern)</h1><h2 id="单例模式所具备条件："><a href="#单例模式所具备条件：" class="headerlink" title="单例模式所具备条件："></a>单例模式所具备条件：</h2><ol><li>构造方法私有化</li><li>对外提供一个公开的静态的获取当前对象的方法</li><li>提供当前类型的静态变量</li></ol><h2 id="单例模式分为两种："><a href="#单例模式分为两种：" class="headerlink" title="单例模式分为两种："></a>单例模式分为两种：</h2><ol><li><p>懒汉式单例(推荐使用)：</p><p> 当调用这个方法时候创建这个对象</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 懒汉式单例</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 静态变量：</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> User user<span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构造方法私有化</span>    <span class="token keyword">private</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 对外提供一个公开获取User的方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> User <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>user<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            user<span class="token punctuation">.</span>a<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> user<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// test</span><span class="token keyword">class</span> <span class="token class-name">UserTest</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user1 <span class="token operator">=</span> User<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 单例模式创建方法</span>        User user2 <span class="token operator">=</span> User<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user1<span class="token operator">==</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// -----> true  当前引用地址指向的相同</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user2<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 其他对象正常调用</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>饿汉式单例：</p><p> 未调用当前方法，这个对象就已经创建出来了</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 饿汉式单例</span><span class="token keyword">class</span> <span class="token class-name">User2</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 因为这是一个静态变量所以当调用这个类时候当前这个对象就已经创建出来了</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> User2 user2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构造方法私有化</span>    <span class="token keyword">private</span> <span class="token function">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 对外提供一个公开获取User的方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> User2 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这里直接返回user2，因为静态方法已经创建出来对象了</span>        user2<span class="token punctuation">.</span>a<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> user2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">UserTest</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        User2 user3 <span class="token operator">=</span> User2<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 单例模式创建方法</span>        User2 user4 <span class="token operator">=</span> User2<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user3<span class="token operator">==</span>user4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// -----> true  当前引用地址指向的相同</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user3<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 其他对象正常调用</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="在实际开发中的作用："><a href="#在实际开发中的作用：" class="headerlink" title="在实际开发中的作用："></a>在实际开发中的作用：</h2><ol><li>在多个模块中都需要一个功能，为了节省空间，所以可以将这个功能做个单例设计模式，什么时候使用，都是创建一个对象</li><li>不会在堆内存中开辟多个空间</li></ol><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>优点：<ol><li>单例模式特点是在一个类中<strong>只能创建一个对象</strong></li><li>单例模式不会影响封装及多态中的使用，只针对与在对象创建时<strong>有且只能有一个对象</strong></li></ol></li><li>缺点：<ol><li>单例模式的类型无法被继承<br> 因为单例模式构造方法是私有的所以一旦继承，子类构造函数默认会调用super()，但是由于单例模式的构造方法是private(私有)所以子类无法访问到父类的构造方法</li><li><code>待总结...</code></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单例模式-singleton-pattern&quot;&gt;&lt;a href=&quot;#单例模式-singleton-pattern&quot; class=&quot;headerlink&quot; title=&quot;单例模式(singleton pattern)&quot;&gt;&lt;/a&gt;单例模式(singleton patt</summary>
      
    
    
    
    <category term="Java" scheme="http://xrebirth.github.io/categories/Java/"/>
    
    
    <category term="Java基础" scheme="http://xrebirth.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>super关键字(16)</title>
    <link href="http://xrebirth.github.io/posts/5f8d3e42.html"/>
    <id>http://xrebirth.github.io/posts/5f8d3e42.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:43:20.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h1><ol><li><p>super不是引用类型,，super中存储的不是内存地址,，super指向的不是父类对象</p></li><li><p>super代表的是前子类对象中的父类型特征</p></li><li><p>什么时候使用 super?<br> 子类和父类中都有某个数据，例如，子类和父类中都有name这个属性<br> 如果要再子类中访问父类中的name属性，需要使用 super</p></li><li><p>super可以用在什么地方？</p><ul><li>可以用在成员方法中，但是<strong>不能用在静态方法中</strong></li><li>super可以用在构造方法中</li></ul></li><li><p>super关键字用在构造方法中:</p><ul><li><p>语法: super(实参);<br>  注意：<strong>super()括号中传入的是实参而不是形参</strong></p></li><li><p>作用：通过子类的构造方法去调用父类的构造方法</p></li><li><p><strong>语法规则（重点）：</strong></p><p>  一个构造方法第一行如果没有this(….);<br>  也没有显示的去调用 super(….);<br>  <strong>系统会默认调用 super();</strong></p><p>  例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 父类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bank</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Bank</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Bank无参构造函数执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 子类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Credit</span> <span class="token keyword">extends</span> <span class="token class-name">Bank</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Credit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 因为这里既没有this()也没有super()，所以JVM默认执行super()</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 测试类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BankTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Credit credit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Credit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// --------->  Bank无参构造函数执行</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在Java语言中只要是创建Java对象，那么Object中的无参数构造方法一定会执行<br>  因为所有方法默认继承于Object</p></li><li><p>注意: super(….);的调用只能放在构造方法的第一行</p></li><li><p>super(….);和this(….);不能共存</p></li><li><p><strong>super(….);调用了父类中的构造方法，但是并不会创建父类对象.</strong></p><p>  通过子类的构造方法去调用父类的构造方法，<br>  作用是：给当前子类对象中的<strong>父类型特征赋值</strong>。</p></li><li><p>注意：<strong>调用构造方法不一定是创建对象</strong></p></li></ul></li><li><p>super()的个人理解：</p><ul><li>super()给当前子类对象中的父类型特征赋值</li><li>因为父类里面成员方法是私有的所以子类无法无法直接访问</li><li> 如果子类调用父类的成员变量还要new一个空间，费空间</li><li> 但是使用super()可以不用创建父类对象直接<strong>间接赋值</strong>然后直接使用父类get方法访问</li></ul><p> 例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 父类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bank</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    Credit credit<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Bank</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Bank</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 子类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Credit</span> <span class="token keyword">extends</span> <span class="token class-name">Bank</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> passWorld<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Credit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Credit</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span><span class="token keyword">int</span> passWorld<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将id传给父类构造函数，但是父类不会创建对象</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>passWorld <span class="token operator">=</span> passWorld<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPassWorld</span><span class="token punctuation">(</span><span class="token keyword">int</span> passWorld<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>passWorld <span class="token operator">=</span> passWorld<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getPassWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> passWorld<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 测试</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Credit credit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Credit</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个子类对象，为父类型特征id赋值100，子类passWorld赋值200</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>credit<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// --------> 父类型特征id=100</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>credit<span class="token punctuation">.</span><span class="token function">getPassWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ----------> passWorld=200</span>        credit<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">74</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 重新定义父类型特征id=74</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>credit<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// -------------> 父类型特征id=74</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;super关键字&quot;&gt;&lt;a href=&quot;#super关键字&quot; class=&quot;headerlink&quot; title=&quot;super关键字&quot;&gt;&lt;/a&gt;super关键字&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;super不是引用类型,，super中存储的不是内存地址,，super指向</summary>
      
    
    
    
    <category term="Java" scheme="http://xrebirth.github.io/categories/Java/"/>
    
    
    <category term="Java基础" scheme="http://xrebirth.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>抽象类(17)</title>
    <link href="http://xrebirth.github.io/posts/5f8d3e42.html"/>
    <id>http://xrebirth.github.io/posts/5f8d3e42.html</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T16:43:25.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><ol><li><p>语法格式：<br> [修饰符] abstract class  类名{}</p></li><li><p>抽象类无法被实例化</p><p> 虽然抽象类没有办法实例化，但是抽象类也有构造方法，该构造方法是给子类创建对象用的</p></li><li><p>抽象类中可以定义抽象方法</p><p> 抽象方法的语法：在方法的修饰符列表中添加abstract关键字，并且抽象方法应该以”;”结束，不能带有”{}”<br> 例如：public abstract void m();</p></li><li><p>抽象类中不一定有抽象方法，但抽象方法<strong>必须</strong>出现在抽象类中</p></li><li><p>一个非抽象的类继承抽象类，必须将抽象类中的抽象方法覆盖，实现，重写</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 动物类</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构造函数</span>    <span class="token keyword">public</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Animal</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 非抽象方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 抽象方法：成员方法</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 猫科类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注意：子类一定要重写父类中的抽象方法不然会编译错误</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"猫会跑步"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 测试类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnimalTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Animal animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        animal<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>抽象类的用途：</p></li><li><p><strong>Java中抽象类更利于代码的维护和重用。</strong></p></li></ol><pre><code>抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。</code></pre><ol start="2"><li>因为抽象类不能实例化对象，所以必须要有子类来实现它之后才能使用。这样就可以把一些具有相同属性和方法的组件进行抽象，这样更有利于代码和程序的维护。</li></ol><pre><code>比如本科和研究生可以抽象成学生，他们有相同的属性和方法。这样当你对其中某个类进行修改时会受到父类的限制，这样就会提醒开发人员有些东西不能进行随意修改，这样可以对比较重要的东西进行统一的限制，也算是一种保护，对维护会有很大的帮助。</code></pre><ol start="3"><li>当又有一个具有相似的组件产生时，只需要实现该抽象类就可以获得该抽象类的那些属性和方法。</li></ol><pre><code>比如学校又新产生了专科生这类学生，那么专科生直接继承学生，然后对自己特有的属性和方法进行补充即可。这样对于代码的重用也是很好的体现。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;语法格式：&lt;br&gt; [修饰符] abstract class  类名{}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;抽象类</summary>
      
    
    
    
    <category term="Java" scheme="http://xrebirth.github.io/categories/Java/"/>
    
    
    <category term="Java基础" scheme="http://xrebirth.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
